#'interaction_generation_seq
#'
#'Generates a sequential series of groups
#'
#'@param pop_mat adjacency matrix of underlying social network
#'@param indiv_data indiv_data dataframe including information on IDs, group membership and spatial locations
#'@param ne number of groups
#'@param mgs mean group size
#'@param style_gs group size distribution. Currently either identical (style_gs=”rep”) or Poisson (style_gs=”pois”).
#'@param par used in jpc to adjust social network connection strengths to probabilities of being sampled in the same group. Defaults to 20
#'@param float used in jpc to provide a minimum probability of being sampled in the same group to allow all groups to be filled. Defaults to 0.0001
#'
#'@details Generates a sequential series of groups (c.f. interaction_generation_simul), whereby each group occurs at a different timestep so can contains overlapping sets of individuals.
#'
#'@return The GBI generated by the function
#'
#'@export

interaction_generation_seq<-function(pop_mat,indiv_data,
                                     ne=1000,mgs=2,style_gs=c("rep","pois"),
                                     par=20,float=0.00001){
  if(style_gs=="rep"){
    gs<-rep(mgs,ne)
  }
  if(style_gs=="pois"){
    gs<-stats::rpois(ne,5)
  }

  n<-nrow(pop_mat)

  gbi<-matrix(0,nrow=ne,ncol=n)
  for(i in 1:ne){
    t_g<-numeric()
    t_g[1]<-sample(indiv_data$indivs,1,replace=FALSE)
    for(j in 2:gs[i]){
      can_join<-indiv_data$indivs[-which(indiv_data$indivs%in%t_g)]
      t_mat<-pop_mat[t_g,can_join]
      if(is.vector(t_mat)){
        join_probs<-t_mat+float
      } else{
        join_probs<-apply(t_mat,2,jpc,par=par,float=float)
      }
      if(length(can_join)>1){
        t_g[j]<-sample(can_join,1,replace=FALSE,prob=join_probs)
      }
      if(length(can_join)==1){
        t_g[j]<-can_join
      }
    }
    gbi[i,t_g]<-1
  }

  return(gbi)

}

