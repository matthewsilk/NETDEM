function (graph, state = NULL) 
{
  if (!is.null(get.edge.attribute(graph, "state"))) {
    state <- get.edge.attribute(graph, "state")
  } else {
    if (is.null(state)) {
      state <- "activating"
    }
  }
  if (is.null(get.edge.attribute(graph, "state"))) {
    E(graph)$state <- state
  }
  graph <- as.undirected(graph, mode = "collapse", edge.attr.comb = function(x) ifelse(any(x %in% 
                                                                                             list(-1, 2, "inhibiting", "inhibition")), 
                                                                                       -1, 1))
  graph <- as.directed(graph, mode = "arbitrary")
  state <- get.edge.attribute(graph, "state")
  if (length(state) == 1) 
    state <- rep(state, length(E(graph)))
  state[state == 2] <- -1
  state[state == 1 | state == 0] <- 1
  if (is.numeric(state)) 
    state[!(state %in% -1:2)] <- sign(state[!(state %in% 
                                                -1:2)])
  if (is.character(state)) {
    state <- as.list(state)
    state[grep("activating", state)] <- 1
    state[grep("activation", state)] <- 1
    state[grep("activate", state)] <- 1
    state[grep("active", state)] <- 1
    state[grep("positive", state)] <- 1
    state[grep("inhibiting", state)] <- -1
    state[grep("inhibition", state)] <- -1
    state[grep("inhibitory", state)] <- -1
    state[grep("inhibit", state)] <- -1
    state[grep("negative", state)] <- -1
    if (is.character(state)) {
      warning("Please give state as a scalar or vector of length(E(graph)): input must be 'activating', 'inhibiting' or an integer")
    }
    state <- unlist(as.numeric(state))
  }
  if (!all(state %in% -1:2)) {
    state <- sign(state)
    warning("State inferred from non-integer weighted edges: Please give numeric states as integers: 0 or 1 for activating, -1 or 2 for inhibiting")
  }
  state_mat <- matrix(1, length(V(graph)), length(V(graph)))
  rownames(state_mat) <- colnames(state_mat) <- names(V(graph))
  if (all(state == 1)) {
    return(state_mat)
  }
  else if (length(V(graph)) == 1) {
    state_mat <- 1
    return(state_mat)
  }
  else if (length(V(graph)) == 2) {
    if (length(state) == 1) {
      state_mat[row(state_mat) != col(state_mat)] <- state
      return(state_mat)
    }
    else {
      warning("only one edge state expected")
    }
  }
  else {
    compute_paths <- function(graph) {
      if (is.connected(graph)) {
        paths <- shortest_paths(as.undirected(graph), 
                                V(graph)$name[1])$vpath
      }
      else {
        subgraphs <- decompose(graph)
        nodes <- sapply(subgraphs, function(subgraph) V(subgraph)$name[1])
        paths <- as.list(rep(NA, length(V(graph))))
        jj <- 0
        for (ii in 1:length(nodes)) {
          subpaths <- shortest_paths(as.undirected(subgraphs[[ii]]), 
                                     V(subgraphs[[ii]])$name[1])$vpath
          paths[jj + 1:length(subpaths)] <- subpaths
          jj <- jj + length(subpaths)
        }
      }
      paths
    }
    paths <- compute_paths(graph)
    is.cyclic <- function(paths) {
      cylic_paths <- sapply(paths, function(path) {
        if (length(path) <= 1) {
          FALSE
        }
        else if (path[1] == path[length(path)]) {
          TRUE
        }
        else {
          FALSE
        }
      })
      any(cylic_paths)
    }
    if (is.cyclic(paths)) {
      warning("Graph contains a cycle, computing minimal spanning tree. This may result in unresolved inhibitions.")
      tree <- minimum.spanning.tree(graph)
      paths <- compute_paths(tree)
      if (is.cyclic(paths)) {
        warning("Graph contains cycles and cannot compute a minimal spanning tree. This will result in unresolved inhibitions.")
        stop()
      }
    }
    paths <- paths[order(sapply(paths, length), decreasing = TRUE)]
    for (ii in 2:length(paths)) {
      remove <- FALSE
      for (jj in 1:(ii - 1)) {
        if (all(names(paths[[ii]]) %in% names(paths[[jj]]))) {
          remove <- TRUE
        }
      }
      if (remove) {
        paths[[ii]] <- NA
      }
    }
    na.omit.list <- function(y) {
      return(y[!sapply(y, function(x) all(is.na(x)))])
    }
    paths <- na.omit.list(paths)
    edges <- as.matrix(get.edgelist(graph))
    for (ii in 1:length(paths)) {
      if (length(paths[[ii]]) > 1) {
        state_path <- c(1, rep(NA, length(paths[[ii]]) - 
                                 1))
        for (jj in 2:length(paths[[ii]])) {
          kk <- which(edges[, 1] == names(paths[[ii]])[jj - 
                                                         1] & edges[, 2] == names(paths[[ii]])[jj] | 
                        edges[, 2] == names(paths[[ii]])[jj - 1] & 
                        edges[, 1] == names(paths[[ii]])[jj])
          if (length(kk) > 1) {
            if (!all(apply(edges[kk, ], 2, function(x) all(x == 
                                                           x[1])))) {
              edges[kk, ][edges[kk[1], 1] != edges[kk, 
                                                   1], ] <- edges[kk, ][edges[kk[1], 1] != 
                                                                          edges[kk, 1], 2:1]
            }
            if (all(apply(edges[kk, ], 2, function(x) all(x == 
                                                          x[1])))) {
              if (all(state[kk] == state[kk][1])) {
                state[kk] <- state[kk][1]
                kk <- kk[1]
              }
              else {
                warning(paste("Conflicting state for redundant edges", 
                              edges[kk[1], 1], edges[kk[1], 2], "with state", 
                              state[kk]))
                Mode <- function(x) unique(x)[which.max(tabulate(match(x, 
                                                                       unique(x))))][1]
                state[kk] <- Mode(state[kk])
                kk <- kk[1]
              }
            }
          }
          if (length(state_path[jj]) == length(state[kk])) {
            state_path[jj] <- state[kk]
          }
          else {
            print(ii)
            print(jj)
            stop("State not compatible with graph paths")
          }
        }
        state_path <- cumprod(state_path)
        if (any(state_path != 1)) {
          state_cross <- state_path %*% t(state_path)
          state_mat[names(paths[[ii]]), names(paths[[ii]])] <- state_cross
        }
      }
    }
    neg_nodes <- colnames(state_mat)[which(state_mat[1, ] == 
                                             -1)]
    pos_nodes <- colnames(state_mat)[2:ncol(state_mat)][which(state_mat[1, 
                                                                        2:ncol(state_mat)] == 1)]
    for (aa in neg_nodes) {
      for (bb in pos_nodes) {
        aa_in_path <- sapply(paths, function(path) aa %in% 
                               names(path))
        bb_in_path <- sapply(paths, function(path) bb %in% 
                               names(path))
        if (!any(aa_in_path & bb_in_path)) {
          state_mat[aa, bb] <- state_mat[bb, aa] <- -1
        }
      }
    }
    for (aa in pos_nodes) {
      for (bb in pos_nodes) {
        aa_in_path <- sapply(paths, function(path) aa %in% 
                               names(path))
        bb_in_path <- sapply(paths, function(path) bb %in% 
                               names(path))
        if (!any(aa_in_path & bb_in_path)) {
          state_mat[aa, bb] <- state_mat[bb, aa] <- 1
        }
      }
    }
    state_mat[t(state_mat) == -1] <- -1
    return(state_mat)
  }
}
<bytecode: 0x000001d27058d8b0>
  <environment: namespace:graphsim>